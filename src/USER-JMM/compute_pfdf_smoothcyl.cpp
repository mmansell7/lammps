/* ----------------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.

   This compute based on lammps-16March18 version of compute_rdf.h. 
   Modifications written by Matt Mansell, jmmansel@ncsu.edu.

------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------
   Contributing authors: Matt Mansell (NCSU), Paul Crozier (SNL), 
                         Jeff Greathouse (SNL)
------------------------------------------------------------------------- */

// A LAMMPS compute to compute the distribution of forces between every
// two points in a cylindrical system with an external potential that
// is dependent only on radial position, and wherein forces are generated by
// interactions between pairwise-interacting classical particles.
// Each point in the system can be identified by rectilinear Cartesian
// coordinates (x1,y1,z1,x2,y2,z2) or by coordinates (r1,theta1,z1,r2,
// theta2,phi2), where r1,theta1,z1 are the usual coordinates in 
// cylindrical geometry, r2 is the Euclidean distance between (r1,
// theta1,z1) and the second point; and theta2 and phi2 are the polar
// and azimuthal angle, respectively, formed by the first and second
// points, where theta2 = 0 is coincident with the z-axis of the first point
// and phi2 = 0 is coincident with the unit radial vector of the first point.


//
// Lammps syntax:
// 
// compute ID group-ID pfdf/smoothcyl file itype1 jtype1 itype2 jtype2 ... keyword/value ...
// 
// ID, group-ID are documented in compute command
// pfdf/smoothcyl = style name of this compute command
// binfile: a file defining the boundaries of the 4D bins
// itypeN = central atom type for Nth PFDF histogram (or asterisk)
// jtypeN = distribution atom type for Nth PFDF histogram (or asterisk)
// 
// zero or more keyword/value pairs may be appended...
//   keyword = cutoff
//     cutoff value = Rcut
//       Rcut = cutoff distance for PFDF computation (distance units)
//


#include <mpi.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "compute_pfdf_smoothcyl.h"
#include "atom.h"
#include "update.h"
#include "force.h"
#include "pair.h"
#include "domain.h"
#include "neighbor.h"
#include "neigh_request.h"
#include "neigh_list.h"
#include "group.h"
#include "math_const.h"
#include "memory.h"
#include "error.h"
#include "comm.h"

using namespace LAMMPS_NS;
using namespace MathConst;

/* ---------------------------------------------------------------------- */

ComputePFDFSmoothcyl::ComputePFDFSmoothcyl(LAMMPS *lmp, int narg, char **arg) :
  Compute(lmp, narg, arg),
  pfdfpair(NULL), npfdfpair(NULL), ilo(NULL), ihi(NULL), jlo(NULL), jhi(NULL),
  hist(NULL), histall(NULL), typecount(NULL), icount(NULL), jcount(NULL),
  duplicates(NULL), cnodes(NULL), cvals(NULL)
{

// Arguments:
// 0. ID
// 1. group-ID
// 2. pfdf/smoothcyl
// 3. bins, tent_pole : defines whether histogram binning or tent pole basis functions are used
// 4. Nbin    : defines number of bins/nodes in each dimension
// 5. itype1
// 6. jtype1
// 7. itype2
// 8. jtype2
// 9. itype3...
// ?. keyword
// ?+1. value
// ?+2. keyword
// ?+3. value...

  //printf("\n\nArguments to pfdf/smoothcyl:\n");
  //for (int n = 0; n < narg; n++) {
  //  printf("%d: %s\n",n,arg[n]);
  //}
  //printf("\n");
  //fflush(stdout);

  cyl_radius_max = 1.5;
  
  if (narg < 5  || (narg-5) % 2)      error->all(FLERR,"Illegal compute pfdf command. Too few arguments (narg < 5).");

  array_flag = 1;
  extarray = 0;
  
  if (strcmp(arg[3],"bins") == 0) {
    //printf("Using %s as basis functions for pfdf.\n",arg[3]);
    //fflush(stdout);
    bin_type_flag = 0;
  }
  else if (strcmp(arg[3],"tent_pole") == 0) {
    //printf("Using %s functions as basis for pfdf.\n",arg[3]);
    //fflush(stdout);
    bin_type_flag = 1;
  }
  else {
    error->all(FLERR,"Illegal compute pfdf command. Unknown binning argument.");
  }

  numr1 = force->inumeric(FLERR,arg[4]);   // # of bins, or # of nodes minus 1, in r1
  numr2 = numr1;                           // # of bins, or # of nodes minus 1, in r2 minus 1
  numtheta2 = numr1;                       // # of bins, or # of nodes minus 1, in theta2 minus 1
  numphi2 = numr1;                         // # of bins, or # of nodes minus 1, in phi2 minus 1
  
  if (numr1 < 1) error->all(FLERR,"Illegal compute pfdf command. Number of r1 bins/nodes is too small.");
  if (numr2 < 1) error->all(FLERR,"Illegal compute pfdf command. Number of r2 bins/nodes is too small.");
  if (numtheta2 < 1) error->all(FLERR,"Illegal compute pfdf command. Number of theta2 bins/nodes is too small.");
  if (numphi2 < 1) error->all(FLERR,"Illegal compute pfdf command. Number of phi2 bins/nodes is too small.");

  // Tent pole basis functions are associated with boundaries between subspaces, rather than 
  // within each subspace, so require one extra basis function more than histograms in each dimension
  // to span the same space
  if (bin_type_flag == 0) {
    nnodestotal = numr1*numr2*numtheta2*numphi2;                  // Total # of pfdf bins
    cnodenum = 1;
  }  
  else if ( bin_type_flag == 1) {
    nnodestotal = (numr1+1)*(numr2+1)*(numtheta2+1)*(numphi2+1);  // total # of pfdf nodes
    cnodenum = 16;
  }
  else error->all(FLERR,"Unknown binning argument.");
  
  //printf("numr1,numr2,numtheta2,numphi2,nnodestotal = %d,%d,%d,%d,%d\n",numr1,numr2,numtheta2,numphi2,nnodestotal);
  //fflush(stdout);

  // optional args
  // nargpair = # of pairwise args, starting at iarg = 4

  cutflag = 0;

  int iarg;
  for (iarg = 5; iarg < narg; iarg++)
    if (strcmp(arg[iarg],"cutoff") == 0) break;

  int nargpair = iarg - 5;

  while (iarg < narg) {
    if (strcmp(arg[iarg],"cutoff") == 0) {
      if (iarg+2 > narg) error->all(FLERR,"Illegal compute pfdf command. Cutoff keyword with no value.");
      cutoff_user = force->numeric(FLERR,arg[iarg+1]);
      if (cutoff_user <= 0.0) cutflag = 0;
      else cutflag = 1;
      iarg += 2;
    } else error->all(FLERR,"Illegal compute pfdf command. Cutoff must be the final keyword.");
  }

  //printf("pfdf cutoff = %.5G\n",cutoff_user);
  //fflush(stdout);
  // pairwise args

  if (nargpair == 0) npairs = 1;
  else npairs = nargpair/2;   // number of pair type sets for which pfdf should be calculated
  //printf("npairs = %d\n",npairs);
  //fflush(stdout);
  
  size_array_rows = nnodestotal;
  size_array_cols = 4 + 4*npairs;

  int ntypes = atom->ntypes;
  memory->create(pfdfpair,npairs,ntypes+1,ntypes+1,"pfdf:pfdfpair");
  memory->create(npfdfpair,ntypes+1,ntypes+1,"pfdf:npfdfpair");
  ilo = new int[npairs];
  ihi = new int[npairs];
  jlo = new int[npairs];
  jhi = new int[npairs];

  if (nargpair == 0) {              // If no pair type sets are explicitly defined
    ilo[0] = 1; ihi[0] = ntypes;    // then i,j sums go over all i atom types and j atom types
    jlo[0] = 1; jhi[0] = ntypes;
  }
  else {
    npairs = 0;
    iarg = 5;
    while (iarg < 5+nargpair) {
      force->bounds(FLERR,arg[iarg],atom->ntypes,ilo[npairs],ihi[npairs]);  // Set the ranges of atom combinations
      force->bounds(FLERR,arg[iarg+1],atom->ntypes,jlo[npairs],jhi[npairs]); // used in each pair type set.
      if (ilo[npairs] > ihi[npairs] || jlo[npairs] > jhi[npairs])
        error->all(FLERR,"Illegal compute pfdf command");
      npairs++;  // Proceed to next pair type set
      iarg += 2;  
    }
  }
  //printf("npairs = %d\n",npairs);
  //fflush(stdout);

  int i,j;
  for (i = 1; i <= ntypes; i++)
    for (j = 1; j <= ntypes; j++)
      npfdfpair[i][j] = 0;     

  // For each pair type set, m, and each pair combination, i,j, within that set,
  // set npfdfpair[i][j] to the total number of sets of which i,j is a member,
  // and set pfdfpair[k][i][j] to m so that if pair combination 3,7 contributes to 
  // three pair sets (m=0,m=2,m=5) then pfdfpair[k][3][7] = 0,2,5 for exactly one
  // value of k each.
  //
  // npfdfpair[i][j] is the number of pair type sets to which pair type i,j contributes in g(r).
  // pfdfpair[k][i][j] is pair type set to which pair type i,j contributes for the kth time.
  for (int m = 0; m < npairs; m++)
    for (i = ilo[m]; i <= ihi[m]; i++)
      for (j = jlo[m]; j <= jhi[m]; j++)
        pfdfpair[npfdfpair[i][j]++][i][j] = m;

  memory->create(hist,npairs,nnodestotal,4,"pfdf:hist");
  /*for (int ii = 0; ii < npairs; ii++) {
    for (int jj = 0; jj < nnodestotal; jj++) {
      for (int kk = 0; kk < 3; kk++) {
        printf("hist[%d][%d][%d] = 1\n",ii,jj,kk);
        fflush(stdout);
        hist[ii][jj][kk] = 1.0;
      }
    }
  }*/
  memory->create(histall,npairs,nnodestotal,4,"pfdf:histall");
  memory->create(array,nnodestotal,4+4*npairs,"pfdf:array");
  typecount = new int[ntypes+1];
  icount = new int[npairs];
  jcount = new int[npairs];
  duplicates = new int[npairs];
  cnodes = new int[cnodenum];
  cvals = new double[cnodenum];
  
  dynamic = 0;
  natoms_old = 0;

  //printf("ComputePFDFSmoothcyl object instantiated.\n");
  //fflush(stdout);
}

/* ---------------------------------------------------------------------- */

ComputePFDFSmoothcyl::~ComputePFDFSmoothcyl()
{
  memory->destroy(pfdfpair);
  memory->destroy(npfdfpair);
  delete [] ilo;
  delete [] ihi;
  delete [] jlo;
  delete [] jhi;
  memory->destroy(hist);
  memory->destroy(histall);
  memory->destroy(array);
  delete [] typecount;
  delete [] icount;
  delete [] jcount;
  delete [] duplicates;
  delete [] cnodes;
  delete [] cvals;
}

/* ---------------------------------------------------------------------- */

void ComputePFDFSmoothcyl::init()
{
  
  if (!force->pair && !cutflag)
    error->all(FLERR,"Compute pfdf requires a pair style be defined "
               "or cutoff specified");

  if (cutflag) {
    double skin = neighbor->skin;
    mycutneigh = cutoff_user + skin;

    double cutghost;            // as computed by Neighbor and Comm
    if (force->pair)
      cutghost = MAX(force->pair->cutforce+skin,comm->cutghostuser);
    else
      cutghost = comm->cutghostuser;

    if (mycutneigh > cutghost)
      error->all(FLERR,"Compute pfdf cutoff exceeds ghost atom range - "
                 "use comm_modify cutoff command");
    if (force->pair && mycutneigh < force->pair->cutforce + skin)
      if (comm->me == 0)
        error->warning(FLERR,"Compute pfdf cutoff less than neighbor cutoff - "
                       "forcing a needless neighbor list build");

    //delr2 = cutoff_user / nbintotal;
    delr2 = cutoff_user / numr2;
  } //else delr = force->pair->cutforce / nbin;
  else {
    delr2 = force->pair->cutforce / numr2;
  }
  
  delr2inv = 1.0/delr2;

  delr1 = cyl_radius_max / numr1;
  delr1inv = 1.0/delr1;
  deltheta2 = MY_PI2/numtheta2;     // MY_PI2 is defined as pi/2 in math_const.h
  deltheta2inv = 1.0/deltheta2;
  delphi2 = MY_PI/numphi2;       // MY_PI is similarly defined in math_const.h
  delphi2inv = 1.0/delphi2;
  
  //printf("delr1,delr2,deltheta2,delphi2 = %.5G,%.5G,%.5G,%.5G\n",delr1,delr2,deltheta2,delphi2);
  //fflush(stdout);
  
  // set 1st through 4th columns of output array to node coords
  if (bin_type_flag == 0) {
    int q = 0;
    for (int i = 0; i < numr1; i++) {
      for (int j = 0; j < numr2; j++) {
        for (int k = 0; k < numtheta2; k++) {
          for (int l = 0; l < numphi2; l++) {
            array[q][0] = (i + 0.5) * delr1;
            array[q][1] = (j + 0.5) * delr2;
            array[q][2] = (k + 0.5) * deltheta2;
            array[q][3] = (l + 0.5) * delphi2;
            //printf("array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",q,array[q][0],array[q][1],array[q][2],array[q][3]);
            q++;
          }
        }
      }
    }
  }
  else if (bin_type_flag == 1) {
    int q = 0;
    for (int i = 0; i < numr1+1; i++) {
      for (int j = 0; j < numr2+1; j++) {
        for (int k = 0; k < numtheta2+1; k++) {
          for (int l = 0; l < numphi2+1; l++) {
            array[q][0] = i * delr1;
            array[q][1] = j * delr2;
            array[q][2] = k * deltheta2;
            array[q][3] = l * delphi2;
            //printf("array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",q,array[q][0],array[q][1],array[q][2],array[q][3]);
            q++;
          }
        }
      }
    }
  }

  // initialize normalization, finite size correction, and changing atom counts

  natoms_old = atom->natoms;
  dynamic = group->dynamic[igroup];
  if (dynamic_user) dynamic = 1;
  init_norm();

  // need an occasional half neighbor list
  // if user specified, request a cutoff = cutoff_user + skin
  // skin is included b/c Neighbor uses this value similar
  //   to its cutneighmax = force cutoff + skin
  // also, this NeighList may be used by this compute for multiple steps
  //   (until next reneighbor), so it needs to contain atoms further
  //   than cutoff_user apart, just like a normal neighbor list does

  // Call Neighbor::request to request a pairwise neighbor list, and return
  // the int specifying the index of the request.
  int irequest = neighbor->request(this,instance_me);
  
  
  neighbor->requests[irequest]->pair = 0;
  neighbor->requests[irequest]->compute = 1;
  neighbor->requests[irequest]->occasional = 1;
  if (cutflag) {
    neighbor->requests[irequest]->cut = 1;
    neighbor->requests[irequest]->cutoff = mycutneigh;
  }
}

/* ---------------------------------------------------------------------- */

void ComputePFDFSmoothcyl::init_list(int id, NeighList *ptr)
{
  list = ptr;
}

/* ---------------------------------------------------------------------- */

void ComputePFDFSmoothcyl::init_norm()
{
  int i,j,m;

  // count atoms of each type that are also in group

  const int nlocal = atom->nlocal;
  const int ntypes = atom->ntypes;
  const int * const mask = atom->mask;
  const int * const type = atom->type;

  for (i = 1; i <= ntypes; i++) typecount[i] = 0;
  for (i = 0; i < nlocal; i++)
    if (mask[i] & groupbit) typecount[type[i]]++;

  // icount = # of I atoms participating in I,J pairs for each histogram
  // jcount = # of J atoms participating in I,J pairs for each histogram
  // duplicates = # of atoms in both groups I and J for each histogram

  for (m = 0; m < npairs; m++) {
    icount[m] = 0;
    for (i = ilo[m]; i <= ihi[m]; i++) icount[m] += typecount[i];
    jcount[m] = 0;
    for (i = jlo[m]; i <= jhi[m]; i++) jcount[m] += typecount[i];
    duplicates[m] = 0;
    for (i = ilo[m]; i <= ihi[m]; i++)
      for (j = jlo[m]; j <= jhi[m]; j++)
        if (i == j) duplicates[m] += typecount[i];
  }

  int *scratch = new int[npairs];
  MPI_Allreduce(icount,scratch,npairs,MPI_INT,MPI_SUM,world);
  for (i = 0; i < npairs; i++) icount[i] = scratch[i];
  MPI_Allreduce(jcount,scratch,npairs,MPI_INT,MPI_SUM,world);
  for (i = 0; i < npairs; i++) jcount[i] = scratch[i];
  MPI_Allreduce(duplicates,scratch,npairs,MPI_INT,MPI_SUM,world);
  for (i = 0; i < npairs; i++) duplicates[i] = scratch[i];
  delete [] scratch;
}

/* ---------------------------------------------------------------------- */

void ComputePFDFSmoothcyl::compute_array()
{
  int i,j,k,m,ii,jj,rr,inum,jnum,itype,jtype,ipair,jpair;
  int inode,ihisto,icontr;
  double delx,dely,delz,rsq,fff,ffx,ffy,ffz,f2rho,f2phi,f2z,eng,f2particle;
  int *ilist,*jlist,*numneigh,**firstneigh;
  double factor_lj,factor_coul;
  double rij[4],rji[4];
 
  // Print 1st through 4th columns of output array
//  int q = 0;
//  for (int i = 0; i < numr1+1; i++) {
//    for (int j = 0; j < numr2+1; j++) {
//      for (int k = 0; k < numtheta2+1; k++) {
//        for (int l = 0; l < numphi2+1; l++) {
//          printf("CHECK: array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",q,array[q][0],array[q][1],array[q][2],array[q][3]);
//          q++;
//        }
//      }
//    }
//  }
  
  //printf("Computing pfdf array.\n");
  //fflush(stdout);
  
  if (natoms_old != atom->natoms) {
    dynamic = 1;
    natoms_old = atom->natoms;
  }
  

  // if the number of atoms has changed or we have a dynamic group
  // or dynamic updates are requested (e.g. when changing atom types)
  // we need to recompute some normalization parameters
  if (dynamic) init_norm();
  

  // Update the variable holding the value of the last timestep on which
  // compute_array was called.
  invoked_array = update->ntimestep; 

  // invoke half neighbor list (will copy or build if necessary)
  neighbor->build_one(list);

  inum = list->inum;    // (int) Length of the neighborlists list
  ilist = list->ilist;  // (int*) Array of atoms for which neighbor lists exist
  numneigh = list->numneigh;     // (int*) Array of engths of each neighbor list
  firstneigh = list->firstneigh; // (int**) Pointer to the array of neighbors of each atom

  //printf("Zeroing histogram bins/nodes for pfdf array.\n");
  //fflush(stdout);
  
  // zero the histogram counts
  for (i = 0; i < npairs; i++) {
    for (j = 0; j < nnodestotal; j++) {
      for (k = 0; k < 4; k++) {
        hist[i][j][k] = 0;
        //printf("hist[%d][%d][%d] = %.5G\n",i,j,k,hist[i][j][k]);
        //fflush(stdout);
      }
    }
  }

  // Print 1st through 4th columns of output array
  int a, q = 0;

  if ( bin_type_flag == 0 ) a = 0;
  else if ( bin_type_flag == 1) a = 1;

  //for (int i = 0; i < numr1+a; i++) {
  //  for (int j = 0; j < numr2+a; j++) {
  //    for (int k = 0; k < numtheta2+a; k++) {
  //      for (int l = 0; l < numphi2+a; l++) {
  //        printf("CHECK: array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",q,array[q][0],array[q][1],array[q][2],array[q][3]);
  //        q++;
  //      }
  //    }
  //  }
  //}
  //printf("Done setting array[:][0:3].\n");
  //fflush(stdout);
  
  // tally the PFDF
  // both atom i and j must be in fix group
  // itype,jtype must have been specified by user
  // consider I,J as one interaction even if neighbor pair is stored on 2 procs
  // tally I,J pair each time I is central atom, and each time J is central

  double **x = atom->x;
  int *type = atom->type;
  int *mask = atom->mask;
  int nlocal = atom->nlocal;

  double *special_coul = force->special_coul;
  double *special_lj = force->special_lj;
  int newton_pair = force->newton_pair;
  double phi1,phi2,frho1,frho2,fphi1,fphi2;

  for (ii = 0; ii < inum; ii++) {
    i = ilist[ii];
    if (!(mask[i] & groupbit)) continue;
    itype = type[i];
    jlist = firstneigh[i];
    jnum = numneigh[i];
    
    for (jj = 0; jj < jnum; jj++) {
      j = jlist[jj];
      factor_lj = special_lj[sbmask(j)];
      factor_coul = special_coul[sbmask(j)];
      // Remove the bits that encode whether a j atom of an i-j pair is a "special" 
      // pair, i.e. part of a topological pair, angle or dihedra
      j &= NEIGHMASK; 

      // if both weighting factors are 0, skip this pair
      // could be 0 and still be in neigh list for long-range Coulombics
      // want consistency with non-charged pairs which wouldn't be in list

      if (factor_lj == 0.0 && factor_coul == 0.0) continue;

      if (!(mask[j] & groupbit)) continue;

      jtype = type[j];
      ipair = npfdfpair[itype][jtype];
      jpair = npfdfpair[jtype][itype];
      if (!ipair && !jpair) continue;
      
      // Calculate the total force.
      delx = x[j][0] - x[i][0];
      dely = x[j][1] - x[i][1];
      delz = x[j][2] - x[i][2];
      rsq  = delx*delx + dely*dely + delz*delz;
      eng  = force->pair->single(i,j,itype,jtype,rsq,factor_coul,factor_lj,fff);
      ffx  = -fff*delx;
      ffy  = -fff*dely;
      ffz  = -fff*delz;
      if ( delz < 0.0 ) ffz  = -ffz;
      //printf("fff,delz,-fff*delz,ffz = %.5G,%.5G,%.5G,%.5G\n",fff,delz,-fff*delz,ffz);
      //fflush(stdout);
      phi1  =  atan2(x[i][1],x[i][0]);
      phi2  =  atan2(x[j][1],x[j][0]);
      
      if (ipair) {
        transform_to_cylsph(x[i],x[j],rij);
        distribute_to_nodes(rij,cnodes,cvals);
        
        frho1 =   ffx*cos(phi1) + ffy*sin(phi1);
        fphi1 =  -ffx*sin(phi1) + ffy*cos(phi1);
        if ( rij[3] < 0 ) fphi1 = -fphi1;
        
        for (ihisto = 0; ihisto < ipair; ihisto++) {
          for (icontr = 0; icontr < cnodenum; icontr++) {
            //hist[pfdfpair[ihisto][itype][jtype]][cnodes[icontr]] += fff*cvals[icontr];
            hist[pfdfpair[ihisto][itype][jtype]][cnodes[icontr]][0] += frho1*cvals[icontr];
            hist[pfdfpair[ihisto][itype][jtype]][cnodes[icontr]][1] += fphi1*cvals[icontr];
            hist[pfdfpair[ihisto][itype][jtype]][cnodes[icontr]][2] += ffz*cvals[icontr];
            hist[pfdfpair[ihisto][itype][jtype]][cnodes[icontr]][3] += 1;
            //printf("Ipair %d,%d at (%.5G,%.5G,%.5G,%.5G,%.5G,%.5G) [spherocylindrical coordinates (%.5G,%.5G,%.5G,%5G)] contributing force [frho,fphi,fz,fmagnitude] (%.5G,%.5G,%.5G,%.5G) to hist[%d][%d], whose total is now: %.5G,%.5G,%.5G\n",i,j,x[i][0],x[i][1],x[i][2],x[j][0],x[j][1],x[j][2],rij[0],rij[1],rij[2],rij[3],frho1*cvals[icontr],fphi1*cvals[icontr],ffz*cvals[icontr],fff*sqrt(rsq)*cvals[icontr],pfdfpair[ihisto][itype][jtype],cnodes[icontr],hist[pfdfpair[ihisto][itype][jtype]][cnodes[icontr]][0],hist[pfdfpair[ihisto][itype][jtype]][cnodes[icontr]][1],hist[pfdfpair[ihisto][itype][jtype]][cnodes[icontr]][2]);
            //fflush(stdout);
          }
        }
      }
      
      if ( (newton_pair || j < nlocal) && jpair ) {
        transform_to_cylsph(x[j],x[i],rji);
        distribute_to_nodes(rji,cnodes,cvals);
        
        ffx   = -ffx;
        ffy   = -ffy;
        frho2 =  ffx*cos(phi2) + ffy*sin(phi2);
        fphi2 =  -ffx*sin(phi2) + ffy*cos(phi2);
        if ( rji[3] < 0 ) fphi2 = -fphi2;

        for (ihisto = 0; ihisto < jpair; ihisto++) {
          for (icontr = 0; icontr < cnodenum; icontr++) {
            //hist[pfdfpair[ihisto][jtype][itype]][cnodes[icontr]] += fff*cvals[icontr];
            //printf("jpair. Adding (%.5G,%.5G,%.5G,%.5G) to hist[%d][%d][%d:%d]...\n",fff*cvals[icontr],ffx*cvals[icontr],ffy*cvals[icontr],ffz*cvals[icontr],pfdfpair[ihisto][jtype][itype],cnodes[icontr],0,2);
            hist[pfdfpair[ihisto][jtype][itype]][cnodes[icontr]][0] += frho2*cvals[icontr];
            hist[pfdfpair[ihisto][jtype][itype]][cnodes[icontr]][1] += fphi2*cvals[icontr];
            hist[pfdfpair[ihisto][jtype][itype]][cnodes[icontr]][2] += ffz*cvals[icontr];
            hist[pfdfpair[ihisto][jtype][itype]][cnodes[icontr]][3] += 1;
            //printf("Jpair %d,%d at (%.5G,%.5G,%.5G,%.5G,%.5G,%.5G) [spherocylindrical coordinates (%.5G,%.5G,%.5G,%5G)] contributing force [frho,fphi,fz,fmagnitude] (%.5G,%.5G,%.5G,%.5G) to hist[%d][%d], whose total is now: %.5G,%.5G,%.5G\n",j,i,x[j][0],x[j][1],x[j][2],x[i][0],x[i][1],x[i][2],rji[0],rji[1],rji[2],rji[3],frho2*cvals[icontr],fphi2*cvals[icontr],ffz*cvals[icontr],fff*sqrt(rsq)*cvals[icontr],pfdfpair[ihisto][jtype][itype],cnodes[icontr],hist[pfdfpair[ihisto][jtype][itype]][cnodes[icontr]][0],hist[pfdfpair[ihisto][jtype][itype]][cnodes[icontr]][1],hist[pfdfpair[ihisto][jtype][itype]][cnodes[icontr]][2]);
            //fflush(stdout);
          }
        }
      }  
    }
  }
  /*
  for (ii = 0; ii < 10; ii++) {
    hist[0][ii] = inum;
  }
  for (ii = 10; ii < 20; ii++) {
    hist[0][ii] = jnumold;
  }
  for (ii = 20; ii < 30; ii++) {
    hist[0][ii] = ipair;
  }
  for (ii = 30; ii < 40; ii++) {
    hist[0][ii] = jpair;
  }
  for (ii = 40; ii < 50; ii++) {
    hist[0][ii] = qi;
  }
  for (ii = 50; ii < 60; ii++) {
    hist[0][ii] = qj;
  }
  for (ii = 60; ii < 70; ii++) {
    hist[0][ii] = cutflag;
  }
  for (ii = 70; ii < 80; ii++) {
    hist[0][ii] = q3++;
  }
  for (ii = 80; ii < 90; ii++) {
    hist[0][ii] = q4++;
  }
  for (ii = 90; ii < 100; ii++) {
    hist[0][ii] = inum;
  }
  */
  // sum histograms across procs
  
  // Print 1st through 4th columns of output array
  //q = 0;
  //for (int i = 0; i < numr1+a; i++) {
  //  for (int j = 0; j < numr2+a; j++) {
  //    for (int k = 0; k < numtheta2+a; k++) {
  //      for (int l = 0; l < numphi2+a; l++) {
  //        printf("CHECK 0: array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",q,array[q][0],array[q][1],array[q][2],array[q][3]);
  //        q++;
  //      }
  //    }
  //  }
  //}
  
  MPI_Allreduce(hist[0][0],histall[0][0],npairs*nnodestotal*4,MPI_DOUBLE,MPI_SUM,world);

  // Print 1st through 4th columns of output array
  //q = 0;
  //for (int i = 0; i < numr1+a; i++) {
  //  for (int j = 0; j < numr2+a; j++) {
  //    for (int k = 0; k < numtheta2+a; k++) {
  //      for (int l = 0; l < numphi2+a; l++) {
  //        printf("CHECK 1: array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",q,array[q][0],array[q][1],array[q][2],array[q][3]);
  //        q++;
  //      }
  //    }
  //  }
  //}
  
  // convert counts to g(r) and coord(r) and copy into output array
  // vfrac = fraction of volume in shell m
  // npairs = number of pairs, corrected for duplicates
  // duplicates = pairs in which both atoms are the same

  double constant,vol,vol1,vol2,ncoord,r1lower,r1upper,normfac;
  double r2lower,r2upper,theta2lower,theta2upper,phi2lower,phi2upper;

  // For three-dimensional systems
  if (domain->dimension == 3) {
    // The volume of a sphere is 4/3*pi*r^3.
    // So, constant is equal to V_sphere(r) / (r^3 * V_box).
    // Constant can be used to normalize over all possible two-particle
    // coordinates in configurational space.
    // constant = 4.0*MY_PI / (3.0*domain->xprd*domain->yprd*domain->zprd);
    // constant = MY_PI*cyl_radius_max*cyl_radius_max*domain->xprd;
    // constant = vfrac*vfrac;
 
    // Loop over all pair types (m)
    if (bin_type_flag == 0) {
      for (m = 0; m < npairs; m++) {
        // Normalization factor for the number of pairs of this type.
        // If icount is greater than 0, then the normalization factor is
        // equal to the total number of j particles in the system, 
        // corrected to remove the contribution from the central atom
        // when i == j (the second term in normfac true case).
        // If icount is less than 1, then this normalization is zero.
        //normfac = (icount[m] > 0) ? static_cast<double>(jcount[m])
        //          - static_cast<double>(duplicates[m])/icount[m] : 0.0;
        normfac = 1.0;
        ncoord = 0.0;
        // Loop through all bins
        for (inode = 0; inode < nnodestotal; inode++) {
          r1lower     = array[inode][0] - 0.5*delr1;
          r1upper     = array[inode][0] + 0.5*delr1;
          r2lower     = array[inode][1] - 0.5*delr2;
          r2upper     = array[inode][1] + 0.5*delr2;
          theta2lower = array[inode][2] - 0.5*deltheta2;
          theta2upper = array[inode][2] + 0.5*deltheta2;
          phi2lower   = array[inode][3] - 0.5*delphi2;
          phi2upper   = array[inode][3] + 0.5*delphi2;
          
          vol1 = MY_PI * (r1upper*r1upper - r1lower*r1lower) * domain->zprd;
          vol2 = 4.0/3.0 * (r2upper*r2upper*r2upper - r2lower*r2lower*r2lower) * 
                   (cos(theta2lower) - cos(theta2upper)) * (phi2upper - phi2lower);
          vol = vol1*vol2;
          
          if (vol * normfac != 0.0) {
            f2rho = histall[m][inode][0]/vol;
            f2phi = histall[m][inode][1]/vol;
            f2z = histall[m][inode][2]/vol;
            f2particle = histall[m][inode][3]/vol;
            //if (fabs (f2rho + f2phi + f2particle ) > 1E-6) {
            ////  printf("inode,r1lower,r1upper,r2lower,r2upper,theta2lower,theta2upper,phi2lower,phi2upper,vol = %d,%.5G,%.5G,%.5G,%.5G,%.5G,%.5G,%.5G,%.5G,%.5G\n",inode,r1lower,r1upper,r2lower,r2upper,theta2lower,theta2upper,phi2lower,phi2upper,vol);
            ////  printf("inode,frho,fphi,fz,fparticle,vol = %d,%.5G,%.5G,%.5G,%.5G,%.5G\n",inode,histall[m][inode][0],histall[m][inode][1],histall[m][inode][2],histall[m][inode][3],vol);
            //  printf("Compiling array. histall[%d][%d][0:3] = (%.5G,%.5G,%.5G,%.5G), low/high = (%.5G/%.5G,%.5G/%.5G,%.5G/%.5G,%.5G/%.5G),domain->zprd = %.5G, vol = %.5G, f = (%.5G,%.5G,%.5G)\n",m,inode,histall[m][inode][0],histall[m][inode][1],histall[m][inode][2],histall[m][inode][3],r1lower,r1upper,r2lower,r2upper,theta2lower,theta2upper,phi2lower,phi2upper,domain->zprd,vol,f2rho,f2phi,f2z);
            //  fflush(stdout);
            //}
          }
          else {
            f2rho = 0;
            f2phi = 0;
            f2z = 0;
            f2particle = 0;
          }

          array[inode][4+m]   = f2rho;         
          array[inode][4+m+1] = f2phi;
          array[inode][4+m+2] = f2z;
          array[inode][4+m+3] = f2particle;
        }
      }
    }
    else if (bin_type_flag == 1) {
      for (m = 0; m < npairs; m++) {
        // Normalization factor for the number of pairs of this type.
        // If icount is greater than 0, then the normalization factor is
        // equal to the total number of j particles in the system, 
        // corrected to remove the contribution from the central atom
        // when i == j (the second term in normfac true case).
        // If icount is less than 1, then this normalization is zero.
        //normfac = (icount[m] > 0) ? static_cast<double>(jcount[m])
        //          - static_cast<double>(duplicates[m])/icount[m] : 0.0;
        normfac = 1.0;
        ncoord = 0.0;
        // Loop through all bins
        for (inode = 0; inode < nnodestotal; inode++) {
          // printf("CHECK A. array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",inode,array[inode][0],array[inode][1],array[inode][2],array[inode][3]);
          // fflush(stdout);

          // Set upper and lower bounds of the current bin
          r1lower     = array[inode][0];
          r1upper     = r1lower + delr1;
          r2lower     = array[inode][1];
          r2upper     = r2lower + delr2;
          theta2lower = array[inode][2];
          theta2upper = theta2lower + deltheta2;
          phi2lower   = array[inode][3];
          phi2upper   = phi2lower + delphi2;
          
          //printf("CHECK B. array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",inode,array[inode][0],array[inode][1],array[inode][2],array[inode][3]);
          //fflush(stdout);

          // 6D volume of the bin, normalized to the total 6D volume
          vol1 = MY_PI * (r1upper*r1upper - r1lower*r1lower) * domain->zprd;
          vol2 = 4.0/3.0 * (r2upper*r2upper*r2upper - r2lower*r2lower*r2lower) * 
                   (cos(theta2lower) - cos(theta2upper)) * (phi2upper - phi2lower);
          vol = vol1*vol2;
          
          //printf("CHECK C. array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",inode,array[inode][0],array[inode][1],array[inode][2],array[inode][3]);
          //fflush(stdout);

          // Ensure neither the shell volume nor the number of these pairs is zero
          if (vol * normfac != 0.0) {
          //printf("CHECK D. array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",inode,array[inode][0],array[inode][1],array[inode][2],array[inode][3]);
          //fflush(stdout);

            // #### g(r) for this bin is equal to the number of pair counts in this
            // bin divided by the normalized volume of the shell, divided by the
            // number of particles of type i and j in the system.
            // This is equivalent to the i-j density (histall / system volume / bin volume) 
            // divided by the number of i and j particles, corrected.
            //gr = histall[m][ibin] / (vfrac * normfac * icount[m]);
            //f2 = histall[m][inode] / (vol * normfac);
            //printf("Adjusting by volume. histall[%d][%d][%d:%d]/vol = (%.5G,%.5G,%.5G)/%.5G = ",m,inode,0,2,histall[m][inode][0],histall[m][inode][1],histall[m][inode][2],vol);
            //fflush(stdout);
            f2rho = histall[m][inode][0]/vol;
            f2phi = histall[m][inode][1]/vol;
            f2z = histall[m][inode][2]/vol;
            f2particle = histall[m][inode][3]/vol;
            //printf("(%.5G,%.5G,%.5G)...",f2x,f2y,f2z);
            //printf("CHECK E. array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",inode,array[inode][0],array[inode][1],array[inode][2],array[inode][3]);
            //fflush(stdout);

          }
          else {
            //printf("CHECK F. array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",inode,array[inode][0],array[inode][1],array[inode][2],array[inode][3]);
            //fflush(stdout);

            f2rho = 0;
            f2phi = 0;
            f2z = 0;
            f2particle = 0;
            //printf("CHECK G. array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",inode,array[inode][0],array[inode][1],array[inode][2],array[inode][3]);
            //fflush(stdout);

          }
          //if (icount[m] != 0)
            // ncoord is the aggregate number of i-j pairs interacting at the distance of
            // this bin or shorter
            //ncoord += f2 * vfrac * normfac;
            // array is what is communicated to Lammps for output
          //printf("CHECK H. array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",inode,array[inode][0],array[inode][1],array[inode][2],array[inode][3]);
          //fflush(stdout);

          array[inode][4+m]   = f2rho;         
          array[inode][4+m+1] = f2phi;
          array[inode][4+m+2] = f2z;
          array[inode][4+m+3] = f2particle;
          //printf("Setting array[%d][%d:%d] = (%.5G,%.5G,%.5G,%.5G,...,%.5G,%.5G,%.5G)\n",inode,0,6+m,array[inode][0],array[inode][1],array[inode][2],array[inode][3],f2x,f2y,f2z);
          //fflush(stdout);
          //array[ibin][2+2*m] = ncoord;     // Aggregate number of i-j (pair index m) interactions
                                           //   at distance of bin ibin or shorter
        }
      }
    }
  }

  // For two-dimensional systems
  else { 
    error->all(FLERR,"Compute pfdf cutoff is not implemented for - "
                 "2D systems");
  }
  
  // Print 1st through 4th columns of output array
//  q = 0;
//  for (int i = 0; i < numr1+1; i++) {
//    for (int j = 0; j < numr2+1; j++) {
//      for (int k = 0; k < numtheta2+1; k++) {
//        for (int l = 0; l < numphi2+1; l++) {
//          printf("CHECK 2: array[%d][0:3] = (%.5G,%.5G,%.5G,%.5G)\n",q,array[q][0],array[q][1],array[q][2],array[q][3]);
//          q++;
//        }
//      }
//    }
//  }
  
}


/* ---------------------------------------------------------------------- */

void ComputePFDFSmoothcyl::transform_to_cylsph(const double xi[3], const double xj[3], double r[4])
{
  // Coordinates in 3D Cartesian space given by xi (first position) and xj
  // (second position).  Coordinates in reduced 4D cylindrospherical 
  // coordinates (r1,r2,theta,phi) returned in r.  Where:
  //
  // r1: cylindrical r-coordinate of first position
  // r2: absolute distance between first position and second position
  // theta: polar angle between z-axis and the r1->r2 vector
  // phi: azimuthal angle between the xi-xj radial unit vector and 
  //      the cylindrical radial unit vector of the first position

  double r1,phi1,deltaxprime,deltayprime,deltazprime;
  
  //printf("Entering function transform_to_cylsph.\n");
  //fflush(stdout);
  
  r1 = sqrt(xi[0]*xi[0] + xi[1]*xi[1]);
  phi1 = atan2(xi[1],xi[0]);
  deltaxprime =  (xj[0] - xi[0])*cos(phi1) + (xj[1]-xi[1])*sin(phi1);
  deltayprime = -(xj[0] - xi[0])*sin(phi1) + (xj[1]-xi[1])*cos(phi1);
  deltazprime = xj[2] - xi[2];

  r[0] = r1;
  r[1] = sqrt(deltaxprime*deltaxprime + deltayprime*deltayprime + deltazprime*deltazprime);
  r[2] = acos(deltazprime/r[1]);
  r[3] = atan2(deltayprime,deltaxprime);

  //printf("(%.4G, %.4G, %.4G, %.4G, %.4G, %.4G) --> (%.4G, %.4G, %.4G, %.4G)\n",xi[0],xi[1],xi[2],xj[0],xj[1],xj[2],r[0],r[1],r[2],r[3]);
  //printf("Exiting function transform_to_cylsph.\n");
  //fflush(stdout);

}


/* ---------------------------------------------------------------------- */

void ComputePFDFSmoothcyl::distribute_to_nodes(double rij[4],int *cnodes,double *cvals) {
//void ComputePFDFSmoothcyl::dist_nodes(double rij[4],int *cnodes,double *cvals) {
//void dist_nodes(double rij[4],int *cnodes,double *cvals) {
  int inoder1_low ,inoder2_low ,inodetheta2_low ,inodephi2_low;
  int inoder1_high,inoder2_high,inodetheta2_high,inodephi2_high;
  int icontr;
  int out_of_bounds_flag,r1mult,r2mult,theta2mult;
  double rijr[4],relpos_r1,relpos_r2,relpos_theta2,relpos_phi2;
 
  //printf("Entering function distribute_to_nodes.\n");
  //fflush(stdout);
 
  out_of_bounds_flag = 0;
  
  // Transform cylindrospherical coordinates to symmetry-reduced equivalents
  rijr[0] = rij[0];
  rijr[1] = rij[1];
  rijr[2] = MY_PI2 - fabs( rij[2] - MY_PI2 );
  rijr[3] = fabs( rij[3] );

  if (bin_type_flag == 0) {
    //printf("Distribute_to_nodes: bin_type_flag == 0...");
    //fflush(stdout);
 
    inoder1_low     = static_cast<int> (floor(rijr[0] * delr1inv    ));
    if ( ( inoder1_low     < 0 ) || ( inoder1_low > numr1-1 ) ) out_of_bounds_flag = 1;
    
    //printf("r1 node: %d...",inoder1_low);
    //fflush(stdout);
 
    inoder2_low     = static_cast<int> (floor(rijr[1] * delr2inv    ));
    if ( ( inoder2_low     < 0 ) || ( inoder2_low > numr2-1 ) ) out_of_bounds_flag = 1;
    
    //printf("r2 node: %d...",inoder2_low);
    //fflush(stdout);
 
    inodetheta2_low = static_cast<int> (floor(rijr[2] * deltheta2inv));
    if ( ( inodetheta2_low < 0 ) || ( inodetheta2_low > numtheta2-1 ) ) out_of_bounds_flag = 1;
    
    //printf("theta2 node: %d...",inodetheta2_low);
    //fflush(stdout);
 
    inodephi2_low   = static_cast<int> (floor(rijr[3] * delphi2inv  ));
    if ( ( inodephi2_low   < 0 ) || ( inodephi2_low > numphi2-1 ) ) out_of_bounds_flag = 1;
    
    //printf("phi2 node: %d...",inodephi2_low);
    //fflush(stdout);
 
    //printf("low  nodes(r1,r2,theta2,phi2): %d, %d, %d, %d   \n",inoder1_low,inoder2_low,inodetheta2_low,inodephi2_low);
    //printf("high nodes(r1,r2,theta2,phi2): %d, %d, %d, %d   \n",inoder1_high,inoder2_high,inodetheta2_high,inodephi2_high);
    //fflush(stdout);
    
    theta2mult =            (numphi2   );
    r2mult     = theta2mult*(numtheta2 );
    r1mult     = r2mult    *(numr2     );
    
    if ( out_of_bounds_flag > 0 ) {
       //printf("Node is out of bounds and will contribute 0.\n");
       //fflush(stdout);
       cnodes[0] = nnodestotal-1;
       cvals[0] = 0;
    }
    else {
      cnodes[0]  = r1mult*inoder1_low + r2mult*inoder2_low + theta2mult*inodetheta2_low + inodephi2_low ;
      cvals[0]   = 1.0;
      //printf("Node %d will be added to at rate %.5G\n",cnodes[0],cvals[0]);
    }
    
  }
  else if (bin_type_flag == 1) {
    //printf("Distribute_to_nodes: bin_type_flag == 1.\n");
    //fflush(stdout);
 
    inoder1_low        = static_cast<int> (floor(rijr[0] * delr1inv));
    inoder1_high       = static_cast<int> ( ceil(rijr[0] * delr1inv));
    if ( ( inoder1_low < 0 ) || ( inoder1_high > numr1 ) ) out_of_bounds_flag = 1;
    
    inoder2_low        = static_cast<int> (floor(rijr[1] * delr2inv));
    inoder2_high       = static_cast<int> ( ceil(rijr[1] * delr2inv));
    if ( ( inoder2_low < 0 ) || ( inoder2_high > numr2 ) ) out_of_bounds_flag = 1;
    
    inodetheta2_low    = static_cast<int> (floor(rijr[2] * deltheta2inv ) );
    inodetheta2_high   = static_cast<int> ( ceil(rijr[2] * deltheta2inv ) );
    if ( ( inodetheta2_low < 0 ) || ( inodetheta2_high > numtheta2 ) ) out_of_bounds_flag = 1;
    
    inodephi2_low      = static_cast<int> (floor(rijr[3] * delphi2inv) );
    inodephi2_high     = static_cast<int> ( ceil(rijr[3] * delphi2inv) );
    if ( ( inodephi2_low < 0 ) || ( inodephi2_high > numphi2 ) ) out_of_bounds_flag = 1;
    
    //printf("low  nodes(r1,r2,theta2,phi2): %d, %d, %d, %d   \n",inoder1_low,inoder2_low,inodetheta2_low,inodephi2_low);
    //printf("high nodes(r1,r2,theta2,phi2): %d, %d, %d, %d   \n",inoder1_high,inoder2_high,inodetheta2_high,inodephi2_high);
    //fflush(stdout);
    
    theta2mult =            (numphi2   + 1);
    r2mult     = theta2mult*(numtheta2 + 1);
    r1mult     = r2mult    *(numr2     + 1);
    
    if ( out_of_bounds_flag > 0 ) {
      for ( icontr = 0; icontr < 16; icontr++) {
         cnodes[icontr] = nnodestotal;
         cvals[icontr] = 0;
      }
    }
    else {
      cnodes[0]  = r1mult*inoder1_low  + r2mult*inoder2_low  + theta2mult*inodetheta2_low  + inodephi2_low ;
      cnodes[1]  = r1mult*inoder1_low  + r2mult*inoder2_low  + theta2mult*inodetheta2_low  + inodephi2_high;
      cnodes[2]  = r1mult*inoder1_low  + r2mult*inoder2_low  + theta2mult*inodetheta2_high + inodephi2_low ;
      cnodes[3]  = r1mult*inoder1_low  + r2mult*inoder2_low  + theta2mult*inodetheta2_high + inodephi2_high;
      cnodes[4]  = r1mult*inoder1_low  + r2mult*inoder2_high + theta2mult*inodetheta2_low  + inodephi2_low ;
      cnodes[5]  = r1mult*inoder1_low  + r2mult*inoder2_high + theta2mult*inodetheta2_low  + inodephi2_high;
      cnodes[6]  = r1mult*inoder1_low  + r2mult*inoder2_high + theta2mult*inodetheta2_high + inodephi2_low ;
      cnodes[7]  = r1mult*inoder1_low  + r2mult*inoder2_high + theta2mult*inodetheta2_high + inodephi2_high;
      cnodes[8]  = r1mult*inoder1_high + r2mult*inoder2_low  + theta2mult*inodetheta2_low  + inodephi2_low ;
      cnodes[9]  = r1mult*inoder1_high + r2mult*inoder2_low  + theta2mult*inodetheta2_low  + inodephi2_high;
      cnodes[10] = r1mult*inoder1_high + r2mult*inoder2_low  + theta2mult*inodetheta2_high + inodephi2_low ;
      cnodes[11] = r1mult*inoder1_high + r2mult*inoder2_low  + theta2mult*inodetheta2_high + inodephi2_high;
      cnodes[12] = r1mult*inoder1_high + r2mult*inoder2_high + theta2mult*inodetheta2_low  + inodephi2_low ;
      cnodes[13] = r1mult*inoder1_high + r2mult*inoder2_high + theta2mult*inodetheta2_low  + inodephi2_high;
      cnodes[14] = r1mult*inoder1_high + r2mult*inoder2_high + theta2mult*inodetheta2_high + inodephi2_low ;
      cnodes[15] = r1mult*inoder1_high + r2mult*inoder2_high + theta2mult*inodetheta2_high + inodephi2_high;

      relpos_r1     = (rijr[0] - array[cnodes[0]][0]) / delr1;
      relpos_r2     = (rijr[1] - array[cnodes[0]][1]) / delr2;
      relpos_theta2 = (rijr[2] - array[cnodes[0]][2]) / deltheta2;
      relpos_phi2   = (rijr[3] - array[cnodes[0]][3]) / delphi2;
            
      cvals[0]   = (1.0-relpos_r1) * (1.0-relpos_r2) * (1.0-relpos_theta2) * (1.0-relpos_phi2);
      cvals[1]   = (1.0-relpos_r1) * (1.0-relpos_r2) * (1.0-relpos_theta2) * (relpos_phi2)    ;
      cvals[2]   = (1.0-relpos_r1) * (1.0-relpos_r2) * (relpos_theta2)     * (1.0-relpos_phi2);
      cvals[3]   = (1.0-relpos_r1) * (1.0-relpos_r2) * (relpos_theta2)     * (relpos_phi2)    ;
      cvals[4]   = (1.0-relpos_r1) * (relpos_r2)     * (1.0-relpos_theta2) * (1.0-relpos_phi2);
      cvals[5]   = (1.0-relpos_r1) * (relpos_r2)     * (1.0-relpos_theta2) * (relpos_phi2)    ;
      cvals[6]   = (1.0-relpos_r1) * (relpos_r2)     * (relpos_theta2)     * (1.0-relpos_phi2);
      cvals[7]   = (1.0-relpos_r1) * (relpos_r2)     * (relpos_theta2)     * (relpos_phi2)    ;
      cvals[8]   = (relpos_r1)     * (1.0-relpos_r2) * (1.0-relpos_theta2) * (1.0-relpos_phi2);
      cvals[9]   = (relpos_r1)     * (1.0-relpos_r2) * (1.0-relpos_theta2) * (relpos_phi2)    ;
      cvals[10]  = (relpos_r1)     * (1.0-relpos_r2) * (relpos_theta2)     * (1.0-relpos_phi2);
      cvals[11]  = (relpos_r1)     * (1.0-relpos_r2) * (relpos_theta2)     * (relpos_phi2)    ;
      cvals[12]  = (relpos_r1)     * (relpos_r2)     * (1.0-relpos_theta2) * (1.0-relpos_phi2);
      cvals[13]  = (relpos_r1)     * (relpos_r2)     * (1.0-relpos_theta2) * (relpos_phi2)    ;
      cvals[14]  = (relpos_r1)     * (relpos_r2)     * (relpos_theta2)     * (1.0-relpos_phi2);
      cvals[15]  = (relpos_r1)     * (relpos_r2)     * (relpos_theta2)     * (relpos_phi2)    ;
      
    }
  }
  
  //printf("Exiting function distribute_to_nodes.\n");
  //fflush(stdout);
 

}


/* ---------------------------------------------------------------------- */

